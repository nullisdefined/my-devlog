---
title: "TypeORM"
slug: "typeorm"
date: 2025-11-17
tags: []
draft: true
views: 0
---
ORM이 무엇인가? ORM 은 관계형 데이터베이스의 테이블과 애플리케이션 레벨의 객체를 연결해주는 추상화계층이다. 엔티티 클래스 객체를 기반으로 개발자는 SQL 쿼리 직접 작성하지 않고도 데이터를 조회하거나 저장할수있고, 관계가 설정된 엔티티 간의 연결 역시 접근할수있다. 이는 ORM 내부에서 다양한 매핑 과정, 관계로딩, 상태관리 등이 복합적으로 동작하기 때문에 가능하다. 아래에서는 TypeORM을 기준으로 ORM이 내부적으로 어떻게 동작하는지 단계별로 살펴본다.

엔티티 메타데이터 수집

ORM이 엔티티를 이해하는 단계로, 백엔드 애플리케이션이 시작되면 TypeORM은 등록된 엔티티 클래스들을 분석하여 모든 메타데이터를 수집한다. 엔티티에 선언된 @Entity, @Column, @ManyToOne 같은 데코레이터 정보들이 읽혀서 메타데이터로 저장된다. 이를 통해
어떤 엔티티가 어느 테이블에 매핑되는지, 각 필드가 어떤 컬럼과 어떻게 매핑되는지, 컬럼의 타입은 뭐고 제약조건은 어떻게 걸리는지, 어떤 관계가 존재하며 어떤 컬럼이 외래키인지, 관계는 어떤 전략으로 로딩될지 등을 알 수 있다. 결과로 엔티티 인스턴스를 생성한다. 

Dirty Checking

엔티티 인스턴스가 생성되면 ORM은 해당 객체를 내부적으로 추적하기 위해 스냅샷을 유지한다. 스냅샷이란 이 엔티티가 처음 만들어졌을때의 상태다. 이후 save()가 호출되면 ORM은 현재 인스턴스와 스냅샷을 비교하여 어떤 값이 변경되었는지를 판단할수있다. 이것이 Dirty Checking(변경 감지)다.

Repository 메서드 호출 혹은 Query Builder

저장, 수정, 삭제, 조회 등 모든 작업은 결국 SQL로 변환되어 데이터베이스 레벨에서 실행되어야 한다. TypeORM은 엔티티 메타데이터와 변경된 필드를 기반으로 다음 과정을 수행한다.
1. 어느 테이블을 대상으로 해야하는지 결정
2. 어떤 컬럼이 INSERT/UPDATE 대상인지 결정
3. JS 타입을 SQL 타입으로 변환
4. JOIN이 필요한 경우 관계 정보를 기반으로 조인 조건을 생성
5. SQL 쿼리 문자열을 만들고 파라미터 바인딩

관계 로딩
엔티티 간의 관계가 정의되어있으면 ORM은 이를 기반으로 연관된 객체들을 자동으로 로딩하거나 필요할때 불러온다.
1) Eager Loading
엔티티를 조회할 때 항상 관계를 함께 가져오는 방식이다.
ManyToOne 관계에 eager 옵션을 지정하면 프로젝트를 조회할 때마다 User도 자동으로 join 되어 로딩된다.

2) Lazy Loading
필요한 순간에 관계를 로딩하는 방식이다.
관계 필드가 Proxy 객체로 대체되며, 실제 프로퍼티에 접근할 때 쿼리가 실행된다.

3) Explicit Loading
명시적으로 relations 옵션을 지정하여 join을 포함한 쿼리를 수행하는 방식이다.




> [!NOTE] 이 프로젝트의 모든 소스 코드는 [GitHub]()에 공개되어 있습니다. 코드 품질 개선이나 새로운 기능 제안에 대한 피드백은 언제나 환영합니다.