---
title: "싱글턴(Singleton) 패턴"
slug: "dp-singleton"
date: 2025-12-15
tags: ["DP", "Singleton"]
category: "CS/Software Analysis and Design"
draft: true
views: 0
---
## 싱글턴(Singleton) 패턴이란?
싱글턴 패턴은 어떤 클래스가 애플리케이션 전체에서 **오직 하나의 인스턴스만 가지도록 보장**하고, 그 인스턴스에 **전역적으로 접근할 수 있게 만드는 생성패턴**이다.

수학에서 *Single*은 단 하나의 원소만 가지는 집합(e.g., `{0}`)을 뜻하는데, 싱글턴 패턴도 역시 이와 비슷한 맥락을 가진다.
즉, 객체를 여러 개 만들지 않고 **하나만 만들어 공유해서 사용**하는 것이 핵심이다.

## 왜 필요한가?
싱글턴 필요한 이유는 주로 리소스 관점에서 설명된다.

어떤 객체는 다음과 같은 특성을 가진다.
- 생성 비용이 크다 (초기회 시간이 오래 걸림)
- 메모리나 시스템 자원을 많이 사용한다

이런 객체를 필요할 때마다 새로 생성하면, 객체 수에 비례해 리소스 소모가 증가한다.
그래서 **한 번만 생성한 인스턴스를 전역적으로 공유**하는 방식이 더 효율적인 경우가 있다.

### 실사용 예시
- **데이터베이스 커넥션 풀**
	DB 연결 자체는 비용이 크기 때문에, 여러 커넥션을 미리 만들어 관리하는 풀(pool)은 보통 하나의 관리자 인스턴스로 운영된다
- **스레드 풀**
	스레드를 계속 생성·제거하는 대신 미리 만들어 둔 스레드를 재사용하는 구조이며, 중앙 관리 객체 하나면 충분하다
- **파일 시스템 접근 핸들러**
	동일 자원에 대한 핸들러를 여러 개 둘 이유가 없고, 충돌 가능성도 커진다
- **로거(Logger)**
	로그 출력은 애플리케이션 전반에서 공유되어야 하므로 중앙에서 관리되는 형태가 흔하다.

## 싱글턴 구조
싱글턴의 전형적인 구조는 다음과 같다.

1. 생성자를 private으로 숨겨 외부에서 new를 못 하게 막고
2. 클래스 내부에 유일한 인스턴스를 담을 수 있도록 static 필드를 두며
3. 인스턴스를 반환하는 public static getInstance() 메서드를 제공해 이 경로로만 접근할 수 있도록 한다.

즉, 직접적인 생성은 막고 접근 경로 하나만 열어둔다.

## 싱글턴 구현 전략
크게 lazy와 eager 방식으로 나뉜다.

### Lazy Initialization
lazy는 필요로할 때 인스턴스를 생성한다. 실제로 쓰기 전까지는 메모리를 점유하지 않는다는 점에서 효율적이다.
하지만, 멀티스레드 환경에서 안전을 보장할 수 없다.
`instance == null` 검사와 객체 생성이 원자적으로 보장되지 않기 때문에 동시에 들어오면 여러 인스턴스가 만들어질 수 있다.

### Eager Initialization
eager는 (클래스 로딩 시점에) 미리 인스턴스를 생성하는 방식이다. JVM 클래스 로더의 초기화 과정은 스레드 안전성이 보장되는 방식으로 동작하므로 구현이 단순하고 안전하다.
다만 실제로 쓰지 않아도 인스턴스를 만들어 메모리를 차지한다는 trade-off가 존재한다.

### Double-Checked Locking
위 두 방식 사이의 균형을 잡기 위해 여러 변형이 등장한다. 대표적으로 DCL(Double-Checked Locking)은 첫 번째 null 체크로 빠른 경로를 제공하고, 최초 생성 시점에만 synchronized로 보호한 뒤 두 번째 null 체크로 중복 생성을 막는다.
이때 `volatile`을 붙이는 이유는 명령어 재배치와 가시성 문제로, 부분 초기화된 객체를 다른 스레드가 보는 상황을 방지하기 위해서다.
성능과 lazy의 장점을 함께 노릴 수 있지만, 코드가 복잡해지는 단점이 있다.

### Lazy Holder
권장되는 방식으로 Lazy Holder (Bill Pugh 방식)이 있다. 핵심적인 아이디어는 바깥 클래스가 로딩할 때는 인스턴스를 만들지 말고, 내부 정적 클래스 (Holder)가 로딩될 때 인스턴스를 만들자는 것이다.
`getInstance()`가 처음 호출되는 순간에만 Holder가 로딩되고, 클래스 초기화는 JVM이 스레드 안전하게 한 번만 수행되므로 동기화 코드를 쓰지 않아도 된다.
즉, lazy의 장점 + JVM이 보장하는 thread-safe를 동시에 얻는 방식이다.

싱글턴이 thread-safe한지 뿐만아니라, 싱글턴이 깨질 수 있는 경로도 같이 이해해야 한다. 예를 들어 Lazy Holder방식도 기본적인 생성 보장에는 강하지만, 악의적으로 리플렉션으로 private 생성자 호출, 직렬화 후 역직렬화로 새 객체를 생성하는 등의 비정상적인 접근으로 싱글턴 제약이 무너질 수 있다. 그래서 정말 하나만이어야 한다는 요구가 강하다면 enum을 고려하거나 방어 코드를 추가하는 식의 설계가 필요하다.

Java 표준 라이브러리에서도 싱글턴을 쉽게 찾을 수 있다. Runtime.getRuntime()은 JVM 런타임 환경이 프로그램당 하나라는 성격 때문에 싱글턴 형태로 제공되고, Logger.getLogger(name)는 이름 기반으로 캐시에 저장해 재사용하는 방식으로 사실상 싱글턴처럼 동작한다.

모든 패턴이 그렇듯 장점만 장점이 있으면 단점도 있다.

싱글턴 패턴은 모듈 간 의존성이 높아진다. 여러  곳에서 Settings.getInstance()처럼 직접 호출하면, 그 클래스 변경이 많은 모듈로 전파된다.
SOLID 원칙을 위배하는 경향이 있다. SRP 관점에서 클래스가 본래 역할에 더해 인스턴스 생명주기/접근 제어 책임까지 같이 갖게 된다. OCP 관점에서 단일 인스턴스라는 제약 때문에 상황에 따른 확장이 어려워지고, private 생성자는 상속/확장을 막아 구조를 고정시키기 쉽다. DIP 관점에서 클라이언트가 인터페이스가 아니라 구체 클래스의 getInstance()에 매달리기 쉬워, 구현 교체와 mocking해야 하는 테스트가 불편해진다.